# 架构设计

> 开发目标(from吴旭军）：
1、任务间相互不干扰，任务内各个被调用的接口数据共享。1个任务失败或出错退出不影响其它任务；
2、任务执行细节参数优先顺序：消息》配置文件》默认值；
3、任务涉及的各接口通用，能通过组合自由调节；组合通过配置文件配置，消息格式中传约定的组合名称；

## 多进程业务架构
> 先前项目：各算法任务编译成独立的可执行文件，主服务将要传递的参数写入配置文件，启动这些任务，这些任务从配置文件读取参数，执行完毕后退出。这种方式效率低、通用型差。

算法任务可能崩溃，为了不影响其它算法任务，采用多进程业务架构      
mqtt接收到任务后，投递到进程池中  
当一个进程崩溃后，进程池需要补充新进程，并获取返回值（如何知道哪个任务崩溃的？）

进程池的选取：  
1. boost的process类，没看到直接创建子进程执行任务的接口（待研究）
2. github上找了个开源的进程池，需要改造+测试

# 第一版架构（2019.7.24 by lidong）

目前第一版架构的一些关键点：  

1. 主进程启动时，根据配置文件fork出进程池。  

    * 事件机制：父进程和各子进程中独立有epoll事件循环

    * 父子进程通信：socketpair注册到epoll中去，父进程关闭socket[1],监听socket[0]的读事件,并通过socket[0]发送数据给相应子进程；子进程关闭socket[0],监听socket[1]的读事件，并通过socket[1]发送数据给父进程

    * 关于父进程通过mqtt接收数据：mqtt库里有线程在poll等待网络事件，为了mqtt的回调和父进程的事件循环能统一处理，采用self-pipe-trick，在mqtt回调中将数据序列化后发送到注册到epoll中的socket中

    * 关于父子信号处理：同上，为了事件统一处理，将linux专门处理信号的signalfd注册到进程epoll中去

2. 子进程管理  

    * 父进程在收到子进程退出信号（SIGCHLD）后，根据waitpid获取的状态，判断是正常退出，还是异常退出。如果是异常退出，重新fork子进程进入进程池。